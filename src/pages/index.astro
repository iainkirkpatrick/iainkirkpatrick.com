---
import Main from "../layouts/main.astro";

import { SITE_TITLE, SITE_DESCRIPTION } from '../constants';
---
<Main title={SITE_TITLE} description={SITE_DESCRIPTION}>
  <div id="ask-section" class="mt-12 flex flex-1 flex-col w-full gap-10 min-h-[60vh]">
    <div id="output-container" class="flex flex-col w-full"></div>

    <template id="answer-template">
      <div class="py-4 flex flex-col">
        <div class="flex flex-col md:flex-row w-full gap-6 md:gap-12">
          <div class="flex flex-col w-full md:w-1/3">
              <span class="text-xs text-slate-400">question</span>
              <p class="text italic question-text"></p>
          </div>
          <div class="flex flex-col w-full md:w-2/3">
              <span class="text-xs text-slate-400">answer</span>
              <p class="text generated-answer"></p>
              <p class="text-xs text-gray-500 mt-2 answer-reference"></p>
          </div>
        </div>
      </div>
    </template>

    <div id="ask-form-wrapper" class="sticky bottom-10 transition-all duration-300 ease-out" style="filter: drop-shadow(0 0 40px rgba(15, 23, 42, 0.08));">
      <span class="text-xs text-slate-400">prompt form</span>
      <form
        id="ask-form"
        class="p-4 flex flex-col w-full bg-[#F8F9FB] rounded-lg shadow-[0_2px_6px_rgba(15,23,42,0.08)]"
      >
        <div class="relative flex w-full items-start gap-3 bg-white/5 px-4 py-3 backdrop-blur transition focus-within:bg-white/10">
          <textarea
            id="ask-textarea"
            name="prompt"
            required
            placeholder="Ask anything... (about Iain)"
            rows="1"
            spellcheck="false"
            autocomplete="off"
            data-gramm="false"
            class="max-h-48 w-full flex-1 resize-none bg-transparent text-base text-foreground/90 placeholder:text-foreground/50 focus:outline-none"
          />
          <button
            type="submit"
            id="ask-button"
            class="relative inline-flex w-12 h-12 flex-none items-center justify-center rounded-lg border-solid border-black/50 border-2 bg-foreground text-background transition hover:bg-foreground/90 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-white/70 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-950 disabled:pointer-events-none disabled:opacity-40 self-start"
          >
            <span class="sr-only">Submit question</span>
            <span id="ask-button-icon" aria-hidden="true" class="flex items-center justify-center">
              <svg viewBox="0 0 24 24" fill="none" class="h-6 w-6">
                <path d="M5 12h14M12 5l7 7-7 7" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" />
              </svg>
            </span>
            <span id="ask-button-spinner" aria-hidden="true" class="pointer-events-none absolute inset-0 flex items-center justify-center opacity-0 transition-opacity duration-200">
              <span class="h-5 w-5 animate-spin rounded-full border-2 border-background/70 border-t-transparent"></span>
            </span>
          </button>
        </div>
        <p class="mt-2 self-end text-xs text-gray-400">enter to send â€¢ shift + enter for a new line</p>
      </form>
    </div>
  </div>
</Main>

<style>
  #ask-button-icon,
  #ask-button-spinner {
    transition: opacity 0.2s ease;
  }

  #ask-button.is-loading #ask-button-icon {
    opacity: 0;
  }

  #ask-button.is-loading #ask-button-spinner {
    opacity: 1;
  }
</style>

<script>
  const configuredOrigin = import.meta.env.PUBLIC_API_URL;
  const origin = configuredOrigin && configuredOrigin.length ? configuredOrigin : window.location.origin;

  const form = document.getElementById('ask-form') as HTMLFormElement | null;
  const textarea = document.getElementById('ask-textarea') as HTMLTextAreaElement | null;
  const button = document.getElementById('ask-button') as HTMLButtonElement | null;
  const outputContainer = document.getElementById('output-container') as HTMLDivElement | null;
  const answerTemplate = document.getElementById('answer-template') as HTMLTemplateElement | null;
  const formWrapper = document.getElementById('ask-form-wrapper') as HTMLDivElement | null;
  const askSection = document.getElementById('ask-section') as HTMLDivElement | null;

  let activeSource: EventSource | null = null;
  let hasAnchoredForm = false;

  function setButtonLoading (isLoading: boolean) {
    if (!button) return;
    button.disabled = isLoading;
    button.classList.toggle('is-loading', isLoading);
  }

  function anchorFormToBottom () {
    if (hasAnchoredForm || !formWrapper) return;
    hasAnchoredForm = true;

    const finalizeAnchor = () => {
      if (!formWrapper) return;
      formWrapper.classList.remove('mt-6');
      formWrapper.classList.add('sticky', 'bottom-6', 'z-10');
      askSection?.classList.add('pb-24');
    };

    const supportsSmoothScroll = 'scrollBehavior' in document.documentElement.style;
    if (supportsSmoothScroll) {
      formWrapper.scrollIntoView({ behavior: 'smooth', block: 'end' });
      setTimeout(finalizeAnchor, 400);
    } else {
      formWrapper.scrollIntoView(false);
      finalizeAnchor();
    }
  }

  function createTextStreamer (element: HTMLParagraphElement) {
    const CHUNK_SIZE = 3;
    let pendingText = '';
    let frameId = 0;

    const render = () => {
      if (!pendingText.length) {
        frameId = 0;
        return;
      }

      const chunk = pendingText.slice(0, CHUNK_SIZE);
      pendingText = pendingText.slice(CHUNK_SIZE);
      element.innerHTML += chunk;
      frameId = requestAnimationFrame(render);
    };

    return (text: string) => {
      pendingText += text;
      if (!frameId) {
        frameId = requestAnimationFrame(render);
      }
    };
  }

  function createAnswerEntry (prompt: string) {
    if (!outputContainer || !answerTemplate) return null;
    const templateRoot = answerTemplate.content.firstElementChild;
    if (!templateRoot) return null;

    const entry = templateRoot.cloneNode(true) as HTMLDivElement;
    const questionElement = entry.querySelector('.question-text') as HTMLParagraphElement | null;
    const answerElement = entry.querySelector('.generated-answer') as HTMLParagraphElement | null;
    const referenceElement = entry.querySelector('.answer-reference') as HTMLParagraphElement | null;

    if (questionElement) {
      questionElement.textContent = prompt;
    }
    if (answerElement) {
      answerElement.textContent = '';
    }
    if (referenceElement) {
      referenceElement.textContent = '';
    }

    if (outputContainer.children.length > 0) {
      const divider = document.createElement('div');
      divider.className = 'my-6 w-full border-t-2 border-black';
      outputContainer.prepend(divider);
    }

    outputContainer.prepend(entry);

    return {
      answerElement,
      referenceElement,
      streamAnswer: answerElement ? createTextStreamer(answerElement) : null,
    };
  }

  function closeActiveSource () {
    if (activeSource) {
      activeSource.close();
      activeSource = null;
    }
  }

  function finalizeInteraction (options?: { resetForm?: boolean }) {
    const { resetForm = true } = options || {};
    setButtonLoading(false);
    closeActiveSource();
    if (resetForm && form) {
      form.reset();
    }
    if (resetForm && textarea) {
      textarea.style.height = 'auto';
      textarea.focus();
    }
  }


  function handleSubmit (event: SubmitEvent) {
    event.preventDefault();
    if (!textarea) return;

    const prompt = textarea.value.trim();
    if (!prompt.length) return;

    anchorFormToBottom();

    const entryControls = createAnswerEntry(prompt);
    if (!entryControls) {
      console.warn('Unable to render answer entry template.');
      return;
    }

    setButtonLoading(true);
    closeActiveSource();

    const encodedPrompt = encodeURIComponent(prompt);
    const answerSource = new EventSource(`${origin}/ask?input=${encodedPrompt}`);
    activeSource = answerSource;

    answerSource.onmessage = (messageEvent: MessageEvent<string>) => {
      if (activeSource !== answerSource) {
        return;
      }

      if (messageEvent.data === '[DONE]') {
        finalizeInteraction();
        return;
      }

      let data: Record<string, any> = {};
      try {
        data = JSON.parse(messageEvent.data || '{}');
      } catch (error) {
        console.error('Unable to parse answer payload', error);
        return;
      }

      if (entryControls.streamAnswer && typeof data.response === 'string') {
        entryControls.streamAnswer(data.response);
      } else if (entryControls.answerElement && typeof data.response === 'string') {
        entryControls.answerElement.innerHTML += data.response;
      }

      if (entryControls.referenceElement && typeof data.reference === 'string' && !entryControls.referenceElement.textContent?.length) {
        const confidenceSuffix = typeof data.confidence === 'number'
          ? ` (score ${(data.confidence * 100).toFixed(1)}%)`
          : '';
        entryControls.referenceElement.textContent = `Matched question: ${data.reference}${confidenceSuffix}`;
      }
    };

    answerSource.onerror = () => {
      if (activeSource !== answerSource) {
        return;
      }

      finalizeInteraction({ resetForm: false });
      if (entryControls.answerElement) {
        entryControls.answerElement.textContent = 'Sorry, something went wrong. Please try again.';
      }
    };
  }

  if (form) {
    form.addEventListener('submit', handleSubmit);
  }

  if (textarea) {
    textarea.addEventListener('input', function () {
      textarea.style.height = 'auto';
      textarea.style.height = `${textarea.scrollHeight}px`;
    });

    textarea.addEventListener('keydown', function (event) {
      if (event.key === 'Enter' && !event.shiftKey && form) {
        event.preventDefault();
        if (typeof form.requestSubmit === 'function') {
          form.requestSubmit();
        } else {
          form.submit();
        }
      }
    });
  }
</script>
